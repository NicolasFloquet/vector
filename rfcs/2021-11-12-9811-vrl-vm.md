# RFC 9811 - 2021-11-12 - VRL bytecode VM

This RFC proposes implementing a bytecode VM. VRL will be compiled to the bytecode
and executed by this VM, with the aim to significantly improve the performance of
executing VRL scripts.

## Context

This RFC is a follow on from
[rfcs/2021-10-14-9811-vrl-performance.md](https://github.com/vectordotdev/vector/pull/9812)

## Scope

### In scope

This RFC is purely about developing a bytecode VM for VRL.

### Out of scope

Any other performance issues relating to VRL will be discussed in
[rfcs/2021-10-14-9811-vrl-performance.md](https://github.com/vectordotdev/vector/pull/9812)

## Proposal

### Implementation

Vrl compiles to an AST that is then walked during resolution. Each node in that
tree is boxed and stored in disparate regions of memory. As a result walking
the tree means that the CPU caches must be constantly swapped.

Instead we can create a bytecode VM to store the execution of the Vrl program.

Bytecode is essentially a big enum of instructions (that are represented by an integer
using the [num-derive](https://crates.io/crates/num-derive),
[num-traits](https://crates.io/crates/num-traits) crates):

```rust
#[derive(FromPrimitive, ToPrimitive, Copy, Clone, Debug, PartialEq, Eq)]
pub enum OpCode {
    Return = 255,
    Constant,
    Negate,
    Add,
    Subtract,
    Multiply,
    Divide,
    Print,
    Not,
    Greater,
    GreaterEqual,
    Less,
    LessEqual,
    NotEqual,
    Equal,
    Pop,
    JumpIfFalse,
    Jump,
    SetPath,
    GetPath,
    Call,
    ...
}
```

The Vm is a struct comprising of the following fields:

```rust
#[derive(Clone, Debug, Default)]
pub struct Vm {
    instructions: Vec<usize>,
    values: Vec<Literal>,
    targets: Vec<Variable>,
    stack: Vec<Value>,
    ip: usize,
}
```

- instructions

The instructions field is a `Vec` of `OpCode` cast to a usize. The reason for
the cast is because not all instructions are `OpCode`. For example the
instructions `[.., Constant, 12, ..]` when evaluated will load the constant
stored in the `values` `Vec` that is found in position 12 onto the stack.

- values

A list of constant values found in the program. Since the bytecode only
contains integers any actual values must be stored here. This also allows
literals to be deduped.

- targets

A list of paths used in the program, similar to `values`.

- stack

The Vm is a stack based Vm. Every expression that is evaluated pushes the
result on the stack. Every operation pulls the values it uses from the stack.

- ip

The instruction pointer points to the next instruction to evaluate.

With each node of the AST compiled down to just a few bytes and all
instructions held in contiguous memory evaluation of the program should be able
to take full advantage of the CPU cache which should result in much faster
execution.


#### Calling functions

Calling functions in the stdlib will be a case of evaluating each parameter
with the results pushed onto the stack.

Since Vrl allows for named parameters and optional parameters, the compiler
will need to ensure the bytecode evaluates each parameter in a specific order
(likely the order declared in the function). Bytecode will need to be emmitted
for parameters that are not specified in the Vrl script to add a default value
to the stack.


### Optimization

With the code as a single dimension array of Bytecode, it could be possible to
scan the code for patterns and reorganise the Bytecode so it can run in a more
optimal way.

A lot more thought and research needs to go into this before we can consider
implementing these changes.

## Drawbacks

Downsides to using a Vm:

- The code is a bit more complex. With an AST that is walked it is fairly apparent
  what the code will be doing at any point. With a Vm, this is not the case, it
  is harder to look at the instructions in the Vm and follow back to what part
  of the Vrl code is being evaluated. We will need to write some extensive
  debugging tools to allow for decent introspection into the Vm.

  However, VRL is a very simple language, which does also mean the VM will be
  simple.

- We lose some safety that we get from the Rust compiler. There will need
  to be significant fuzz testing to ensure that the code runs correctly under
  all circumstances. It should be noted however that the entire VM will not
  require any _unsafe_ code.

- Currently each stdlib function is responsible for evaluating their own
  parameters. This allows parameters to be lazily evaluated. Most likely with a
  Vm, the parameters will need to be evaluated up front and the stack passed
  into the function. This could impact performance.

## Prior Art

- Goscript - An implementation of Go using a bytecode Vm,
  https://github.com/oxfeeefeee/goscript

- CPython - https://github.com/python/cpython

## Plan Of Attack

- [ ] Submit a PR with spike-level code _roughly_ demonstrating the change for
      the VM.
